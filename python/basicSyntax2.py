'''
온라인 쇼핑몰 장바구니, 스마트 관리
상품 장바구니담고 목록 관리(list), 수량 조절, 할인쿠폰 적용 최종 금액
상품명 - 가격 짝 지어 저장(dict)
멤버십 연산자 : 원하는 상품 있는지 빠른 확인
논리 연산자 : 할인적용 조건 검사
특정상품 중복 확인, 가격 합산 과정 최적화 하려면??
'''


'''
5반 강사님

 (주의0 tuple 인 경우 트레일링 콤마 사용 (1개일때, 엔터)
 a = [1, 2, 3]
 b = [1, 2, 2, 2]
 set 은 중복 제거하고 생성됨, 순서 x
 , list는 중복 허용, 순서o

 <dict 개념>
 : 키 밸류 쌍 구성
 (1) key 사용특징 ? : immutable 이뮤터블 ; 변경불가 자료형만 사용 가능
 ex. str,int,tuple
 key 값 바뀌면 안됨
 뮤터블? list, dict

 (2) value ? 모든 자료형 가능 

 
 <중첩 리스트 list>

: 리스트 안에 리스트 포함

(1) 얕은 복사
copy()
(주소만 같음) 같은 방향 가리킴
객체를 복사하지않음

(2) 깊은 복사
import copy 하고
l4 = copy.deepcopy(l1)
각각 다른 메모리주소로 list 객체까지 복사
원본, 카피본, 메모리 주소, 객체 각각 생성

(3) 복사 x

복사 여부 확인 하단 참고

'''
l1 = [1, 2, 3, [4, 5, 6]] 
l2 = l1 
id(l1)
id(l2) # 두 객체는 같은 주소, 리스트 객체
# 복사 여부 확인 ? 객체 주소값 확인 
# : id() 함수로 객체 주소 파악 가능

#얕은 복사
l1 = [1, 2, 3, [4, 5, 6]] 
l2 = l1 
l3 =l1.copy()
id(l3) # 다른 메모리 주소로 list 복사, 객체 동일

# 깊은 복사
import copy
l4 = copy.deepcopy
id(l4)
# 마저 필기해야함

# < list[] 개념 >
'''
: 여러 값을 순서대로 저장. 
 변경 가능 (시퀸스 자료형), 순서 ㅇ
 대괄호 사용 [ ]
 중첩 가능(list 안에 list)

'''
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'python']

'''
list 는 시퀀스 : 인덱싱, 슬라이싱, 길이 확인, 반복 가능
이하 예시
'''
my_list = [1, 'a', 3, 'b', 5]

#인덱싱(순서에 해당하는 값 출력)
print(my_list[1]) #a 

#슬라이싱
print(my_list[2:4]) # [3, 'b'] 4번째는 짤림
print(my_list[:3]) #[1, 'a', 3]
print(my_list[3:]) #['b', 5] : 끝까지 하면 마지막 요소 출력됨
print(my_list[::2]) #[1, 3, 5]
print(my_list[::-1]) # 음수도 가능 [5, 'b', 3, 'a', 1]
슬라이싱 개념 잘 모르겠음.


## list의 가변성 (부터 메모)
# 변경가능 (수정,추가,삭제) vs 불변성 (수정,추가,삭제 불가)


## tuple 시퀀스 특징 (문제풀때 안씀)
# 시퀀스 공통 특징과 동일
## tuple의 불변성
# tuple odject는 지원 x
# tuple은 변경 불가능 (수정,추가,삭제 불가)
# 왜 불변성 가질까? 목적자체가 개발자가 활용하는 것 아님. 파이썬이 내부동작 위해 사용
# 파이썬 -> 다중할당 가능 / 가변성 가지게 되면 데이터 안정성 떨어짐
# 언패킹(내부동작, 튜플: 개발자관여하는 데이터 타입 아님)
# (개발자도 간접적 활용함.)

# 왜 내부동작에서 list 대신 tuple을 쓸까?
# list는 가변성 때문

'''
range 개념
 : 연속된 시퀀스 생성, 변경 불가
- 반복문과 함께 사용(코드 반복 실행에 유용)

'''

# range 기본 구문
range(start, stop, shep) 
# range는 함수형태. 3개의 값을 받음. 
# 1개 넣을 경우
# range(stop)  
# 2개 넣을 경우
# range(start, stop)
# 3개 넣을 경우
# range(start, stop, step)


# 0부터 셈. 갯수 : n-1
my_range_1 = range(5) # 0부터 5까지
print(my_range_1) # range(0, 5)
print(list(my_range_1)) # [0, 1, 2, 3, 4]
my_range_2 = range(1,10)
print(my_range_2) # range(1, 10)
print(list(my_range_2)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]

my_range_3 = range(5, 0, -1)

## list 형 변환 필요 (그래야 내부 요소 사용가능)
'''
주의
(1) 값의 범위 규칙 
: stop 값은 시퀀스에 절대 포함되지 않음
range(1, 5) # 1,2,3,4
## stop 값 바로 앞에서 시퀀스가 끝난다고 암기

(2) 증가/감소 값 규칙
: step 값은 숫자 시퀀스의 간격과 방향 결정
- step 값이 양수인 경우 (기본값1)
- step 값이 음수인 경우
숫자가 start 값에서 stop 값까지 감소
반드시 start 값은 stop 값보다 커야함
'''


### 오늘 강의 필수 암기 : list , dict

'''
딕셔너리 (dict)
=> 비 시퀀스
: key-value 쌍
순서, 중복 없음, 변경 가능
# 순서가 없다??? 인덱스(고유번호) 없음

딕셔너리 표현
- {} ㅎ안에 값들이 쉼표, 로 구분
- 값 1개는 키,값 쌍으로 구성

각각 순서 자체가 없음, 요소 출력 불가능
키로 접근해야하는데 동일한 키가 있다? 중복 안됨.
값은 중복 가능
딕셔너리 순서???
출력해보면 내가 쓴거 그대로 출력되는데? 내가 넣은 순서.
파이썬 3.7이상부터는 입력순서 -> 출력시 그대로 됨. (개발 원활을 위해)
"출력 순서 보장" 예전에는 안됐음
딕셔너리 본질 : 순서 없음. "key를 통한 접근" 암기

'''
my_dict_1 = {}
my_dict_2 = {'key' : 'value'}
my_dict_3 = {'apple': 12 , 'list': 5, 'banana': 3}

'''
- key 규칙
조건1. 고유해야함 (중복x)
조건2. 변경 불가능한 자료형만 가능
가능 : str, int, float, tuple
불가능: list, dict,

- 값의 규칙
값은 자료형 상관x
딕셔너리 중첩 가능

<딕셔너리 값 접근법>
딕셔너리 [key] # key를 통해 접근
'''
my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}

print(my_dict['name'])  # Alice
print(my_dict['age'])   # 30

# 딕셔버리 가변성 -> 값 추가,변경 가능
'''
딕셔너리 key 값은 불변, 고유한 자료형이어야하지먄, 추가, 변경은 가능
API 다룰 때 딕셔너리 모르면 다룰 수 없음
서버서에서 dict 형으로 자료 선달함.(인적 정보 등)
'''

'''
< set 개념 > 
: 순서x, 중복x, 변경 가능 자료형

set 표현 -> { } 중괄호
# set vs dict 
차이 ? 빈세트 만들 때 my_set_1 = set()

# 튜플이랑 본질 비슷
set 도 많이 활용하지 않음. 집합연산 할때 사용
중복 없음. -> 집합 연산 수행 가능
순서 없음 -> 인덱싱 사용 불가능
'''
my_set_1 = set ()
my_set_2 = 



'''
<set 의 집합 연산>
set 는 수학 집합 개념 가져와서 , 두 데이터 그룹 간 관계 파악에 효과적
중복 제거 ?? -> set형 변환
이하 예시
(튜플, 세트는 알고리즘 공부 중에 우선순위는 낮음)
'''

my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

#합집합
print(my_set_1 | my_set_2) #{1,2,3,6,9}

#차집합
print(my_set_1 - my_set_2) #{1, 2}

# 교집합
print(my_set1 & my_set_2) #{3}


'''
<other types>


(1) None 
: 파이썬이 '값이 없음' 표현
- 내용물 없는 빈 상자 (무x) 표현 : 데이터가 아직 없음(입력x 자리o)
- 값이 존재하지 x, 미정
- 숫자 0, 빈 문자열 '' 과 다름. 
(개발에 많이 사용)
(주의) 반드시 N은 대문자
'''
#my_variable 에는 아직 아무 값도 할당하고 싶지 않을 때

my_variable = None
print(my_variable) #None

'''
(2) boolean
True, False
- 프로그램 흐름 제어할 때 사용 (on off 스위치)
- 비교/논리 연산의 평가 결과로 사용
### 조건문 / 반복문 에도 많이 사용
(주의) T, F 는 대문자
이하 예시
'''
is_active = True
is_logged_in = False

print(is_active) #True
print(is_logged_in) #False
print(10 > 5) #True


'''
<파이썬 Collection>
: 여러 물건 담는 '보관함'. 
파이썬은 목적에 따라 다양한 종류의 컬렉션 제공.
분류 ; str, list, tuple, range(시퀀스) / set, dict (비시퀀스)
(주의) 표로 암기하셈
시퀀스 3개 (순서ㅇ)
- str : 변경 불가능, 순서o
- list : 변경 가능, 순서o
- tuple : 변경 불가능 , 순서o
=============================
비시퀀스 2개 (순서 x)
- dict : 변경 가능, 순서x
- set : 변경 가능, 순서 x

=========================
변경 가능 : lsit , 비시퀀스(dict, set)

=========================
<총정리 불변 vs 가변 >

- 불변 
특징 : 변경 불가, 안전성, 예측 가능
종류 : str, tuple,range

- 가변 
특징 : 값 자체가 통쨰로 메모리에 들어있음 (변경하려면 메모리 부숴야)
(복사해서 사용함. 심화 -> 얕은 복사, 깊은 복사, 가변은 유연한 성질이라서 개발 시 실수하는 개념임.)
실제 list 는 메모리에 저장될 때, [주소, 주소, 주소] 주소들어있음. 인덱스 번호
종류: list, dict, set 


<형 변환 (type 변환)>

: 한 데이터 타입을 다른 데이터 타입으로 변환
(1) 형변환 종류
- 암시적 (자동) : 파이썬이 자동으로 함 (안전한 방향으로)
: 파이썬이 데이터 손실 방지 위해, 더 정밀 타입으로 자동 변환
ex. 
int + float => float (실수가 정수를 포함)
불리언 + 3 => 불리언을 int 1로 봄

- 명시적 (수동) : 
 내가 직접 "함수 지정" 으로 변환
어느 부분을 바꿀지 선택해야함.
ex. 파이썬 내장함수
직접 해봐야함. 구조상 안되는 것 많음. 명시적 형변환 종류 너무 많음

int() 
float()
str()
list()
tuple()
set()

<형변환 안 되는 예> # 다 못외움. 경험필요
str -> int (형식에 맞는 숫자만 가능)

<컬렉션 간 형변환 정리> 암기 x

'''

'''
<< 연산자 >>
1. 산술 연산자
: 수학 계산에 사용

2. 복합 연산자
: 연산 + 할당
연산하고 자기자신에게 재할당하는 사례
ex. a=a+b (수정전) => a+=b (해석: a가 1씩 증가) (수정후)
## 파이썬 : 의미 연산자로 사용해도 괜찮음. 파이썬은 명시적인 코드를 권장.
(연습필요)

3. 비교 연산자
: 불리언 타입 / 두 값 비교해서 그 관계가 맞는지, 틀리는지 불리언으로 반환
! : not(부정) 의미
 < 같음, 같지않음 (2종류) >
!= : 같지않음
== : 같음
is : 같음
is not : 다름

(1) ==(이퀄리티 연산자) : 값이 같음 (같은 값 자체, 주소 달라도 됨)

(2) is 연산자(아이덴티티 연산자) : 객체 자체가 같은지 비교 (값 같고, 메모리주소 같아야함)
(주의) 값, 숫자 비교에 사용 안함

<is 대신 == 써야하는 이유>
90% 는 값을 비교
is(정체성) 비교하는거니까 자주안씀
is 쓰면 안되는경우???
: 사람 의도와 다른 결과 보여주는 문제 발생
사람은 보통 값 비교를 함.(의도)

<is 쓰는 경우???>
싱글턴 객체를 비교할 때 사용
싱글턴 객체 : 특정 값에 대해 파이썬 프로그램 전체에서 딱 1개 객체만 생성되어 재사용됨
ex. None, True, False (권장)
이퀄리티로 써도 동작잘함? yes
None 는 전체에서 메모리 주소 정확히 일치.
(추가 예시)
list , 가변 객체 비교할 때 값 자체 비교 ->  == 사용
두 변수가 완전 동일 객체 가리키는지 비교 -> is 
각각 리스트 객체 비교, 리스트 값은 동일, 서로 다른 독립적 리스트 객체이므로 is 쓰면 결과 Faulse
'''
print(1 is True) #false
# 정수, 불리언 다른 객체임


'''
(3) 논리 연산자
: 여러 조건 조합. True,False 값을 반대로 뒤집을 때 사용
ex. and, or, not
비교 연산자과 같이 사용


<파이썬 단축평가>
파이썬은 or 할때 앞에서 false 나오면 뒤에 평가하지 않음
: 논리 연산에서 2번째 피연산자를 평가하지 않고, 결과를 결정.
(거짓취급하는 경우 -> 빈문자열,거짓,숫자0, 빈 리스트)
(참 취급 -> 참, 거짓아닌 모든 값)
#########시험 나옴 암기 ########
# 5반 강사님
vowels = 'aeiou' 

print(('a' and 'b') in vowels) # False
print(('b' and 'a') in vowels) # True

빈문자열은 false 로 취급
나머지는 True
and 의 경우 true 나옴, 앞, 뒤 모두 비교 -> 끝까지 확인 (단축x)
and 앞에서 false 나옴 -> 앞에서 멈춤(단축o)

or : 앞에서 True 나옴 -> 멈춤 (단축o)
or : 앞에서 false 나옴 -> 뒤 봐야함 (단축 x)
(암기x 이해.)



#
(주의)
비교연산자 결과 : True, False
논리 연산자 결과 : 값, 또는 빈문자열 ''

<단축평가 하는 이유???>
코드 실행 최적화
코드 흐름 제어, 오류 방지
간결 코드 지원

(4) 멤버십 연산자
왼쪽 값 (상관x)
오른쪽 값 은 컬렉션이어야함.
왼쪽에 오른쪽이 있냐없냐?
: 특정 값이 시퀀스나 , 타 컬렉션 안에 포함되어있는지 확인하는 연산자
(많이 씀)

(5) 시퀀스형 연산자

산술 연산자에서 + - 있음 -> 시퀀스에서 사용하면?
시퀀스 연산자에서? +(결합연산자) , *(반복 연산자)
list, tuple 에 사용
피피티 오타 있음. 시퀀스형 연산자 예시

<연산자 우선순위 정리> 전체 암기 x 중요한것만 픽
그룹핑 잘해야함. 

<참고자료> 
trailing comma 
마지막에 쓰는 콤마,
튜플 하나일 때는 필수.
나머지 자료형 선택.
딕셔너리에서 콤마 많이 씀.
나쁜예 : 트레일링 콤마 쓰고 한줄에 작성
'''

#단축평가
# 정수, 0이면 False 로 간주, 0 아니면 True 로 간주(0은 실수)
print(3 and 5) # T , 5
Print(0 and 3) # F ,0
print(0 and 4)


# or 앞 트루 / 뒤 안봄
# or 앞 펄스 / 뒤 트루임
# and 앞 트루 / 뒤 봄
# and 앞 펄스 / 뒤 안봄
